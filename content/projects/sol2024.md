---
id: sol2024
title: "Seed of Light"
summary: "Seed of Light is a tower defense game set in a demon-dominated world, where players strategically deploy allies and defenses to repel demonic forces under real-time combat conditions."
tech:
  - Unity
  - C#
thumbnail: assets/images/sol2024-tb.jpg
order: 5
links:
  itch: https://dw-256.itch.io/seed-of-light
  video: https://www.youtube.com/watch?v=PH3c9m83pCo
---

![Overview](/assets/images/sol2024/sol2024.png "Battle")

## Project Overview

- Real-time tower defense game developed during **GameSeed 2024** under tight event constraints.
- Focused on deployable allies, enemy waves, and readable combat behavior.
- Combat pacing is driven by fixed-interval wave progression rather than player-triggered events.

## Role & Responsibilities

- Implemented core gameplay and AI systems.
- Built deployment, spawning, and performance-critical runtime features.
- Integrated third-party navigation and adapted it to gameplay needs.

<br>
<details>
<summary><strong>Technical Contributions & Engineering Decisions</strong></summary>

### AI Behavior & Targeting

- Implemented **state machineâ€“based AI** for both enemies and deployable allies.
- Each enemy operates with:

  - A **primary objective target** (e.g., base / path endpoint).
  - Conditional engagement logic: attacks **player or allied units when they enter attack range**.
- Both enemies and allies **prioritize the nearest valid target** to keep combat deterministic and readable.
- Chose simple, explicit behavior logic to support rapid tuning and avoid emergent edge cases during the event.

**Trade-off:**
State machines limited complex emergent behavior compared to behavior trees, but significantly reduced iteration cost and debugging overhead under time constraints.

### Navigation

- Integrated **A- Pathfinding Project** for ally and enemy movement in a **2D top-down environment**.
- Selected a proven solution to minimize technical risk and accelerate development.
- Accepted reduced low-level control in exchange for stability, tooling, and predictable behavior.

### NPC Architecture

- Designed **shared NPC logic** to support multiple ally types and enemy archetypes without hard-coded branching.
- Structured behaviors for quick balance adjustments and iteration during playtesting.

### Deployment & Spawning Systems
- Built a **deployment system** handling placement validation, cooldown management, and interaction flow.
- Built flexible **spawn systems** supporting **time-driven, wave-based progression** and **conditional enemy spawns**.
- Waves increment at **fixed time intervals**, with each new wave:
  - Increasing the total enemy spawn count
  - Unlocking new enemy types starting at specific wave thresholds
- Systems were designed to scale combat intensity predictably while remaining performant.

### Performance & Object Pooling

- Implemented **object pooling** to mitigate allocation churn caused by frequent spawning and destruction.
- Identified GC spikes as a risk when combined with pathfinding costs.
- Prioritized stable frame timing over simpler allocation-based workflows to support combat-heavy scenarios.

### Collaboration & Workflow

- Collaborated within a small, cross-functional team using a **Git-based workflow**.
- Managed feature branches and merge resolution during rapid iteration.

</details>

## Outcome

- Delivered a complete, playable tower defense game within the event timeframe.
- Maintained stable performance during high-density combat encounters.
