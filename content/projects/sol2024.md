---
id: sol2024
title: "Seed of Light"
summary: "Seed of Light is a tower defense game set in a demon-dominated world, where players strategically deploy allies and defenses to repel demonic forces under real-time combat conditions."
tech:
  - Unity
  - C#
thumbnail: assets/images/sol2024-tb.jpg
order: 5
links:
  itch: https://dw-256.itch.io/seed-of-light
  video: https://www.youtube.com/watch?v=PH3c9m83pCo
---

### Screenshots
![Overview](/assets/images/sol2024/sol2024.png "Battle")

## Project Overview

- Real-time tower defense game developed during **GameSeed 2024** under tight event constraints.
- Focused on deployable allies, enemy waves, and readable combat behavior.
- Combat pacing is driven by fixed-interval wave progression rather than player-triggered events.

## Role & Responsibilities

- Implemented core gameplay and AI systems.
- Built deployment, spawning, and performance-critical runtime features.
- Integrated third-party navigation and adapted it to gameplay needs.

<br>
<details>
<summary><strong>Technical Contributions & Engineering Decisions</strong></summary>

### AI Behavior & Targeting

- Implemented **state machineâ€“based AI** for both enemies and deployable allies.
- Each enemy operates with:
  - A **primary objective target** (e.g., base or path endpoint).
  - Conditional engagement logic that switches to attacking player or allied units when they enter attack range.
- Both enemies and allies **prioritize the nearest valid target** to keep combat deterministic and readable.

State machines were chosen to keep behavior explicit and debuggable under event constraints. While this limited emergent interactions compared to behavior trees, it significantly reduced iteration and tuning overhead, allowing combat behavior to stabilize early.

### Navigation

- Integrated **A\* Pathfinding Project** for ally and enemy movement in a **2D top-down environment**.
- Selected a proven solution to minimize technical risk and accelerate development.
- Relied on built-in tooling to focus effort on gameplay iteration rather than pathfinding internals.

This reduced low-level control over navigation behavior, particularly under high agent counts. However, predictability and tooling support were more valuable than custom control for a short-lived prototype intended to validate combat flow.

### NPC Architecture

- Designed **shared NPC logic** to support multiple ally types and enemy archetypes without hard-coded branching.
- Centralized behavior configuration to enable rapid balance changes during limited playtesting.

Abstracting NPC logic early prevented brittle, one-off implementations and kept iteration costs low as new unit types were introduced late in development.

### Deployment & Spawning Systems

- Built a **deployment system** handling placement validation, cooldown management, and interaction flow.
- Implemented **time-driven, wave-based spawning** with conditional enemy unlocks at specific wave thresholds.
- Waves advance at fixed intervals, increasing enemy count and variety over time.

Fixed-interval pacing simplified balancing and avoided player-driven pacing exploits during testing. While this reduced player agency compared to trigger-based systems, it allowed difficulty curves and combat clarity to be evaluated consistently.

### Performance & Object Pooling

- Implemented **object pooling** to mitigate allocation churn caused by frequent spawning and destruction.
- Identified garbage collection spikes as a risk when combined with pathfinding and combat logic.
- Prioritized stable frame timing during high-density combat encounters.

Pooling proved essential rather than optional, as pathfinding costs amplified allocation-related performance issues during late-stage testing.

### Collaboration & Workflow

- Collaborated within a small, cross-functional team using a **Git-based workflow**.
- Managed feature branches and resolved merges during rapid iteration cycles.

</details>

## Outcome

- Delivered a complete, playable tower defense game within the event timeframe.
- Achieved stable performance during combat-heavy scenarios.
- Validated the core deploy-and-defend gameplay loop under real-time pressure.
